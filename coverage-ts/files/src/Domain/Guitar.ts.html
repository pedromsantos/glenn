
  <!DOCTYPE html>
  <html>
    <head>
      <title>Guitar.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/Domain/Guitar.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">595</td><td class="">595</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { ClosedChord } from &#x27;./Chord&#x27;;
import Pitch, { MelodicLine, MelodicLineDirection } from &#x27;./Pitch&#x27;;

export class Fret {
  constructor(private string: GuitarString, private fret: number) {}

  get Number(): number {
    return this.fret;
  }

  isHigher(other: Fret, margin = 0) {
    return this.fret + margin &gt; other.fret;
  }

  isLower(other: Fret, margin = 0) {
    return this.fret - margin &lt; other.fret;
  }

  isSame(other: Fret) {
    return this.fret === other.fret &amp;&amp; this.string.isSame(other.string);
  }

  isSameFret(other: Fret) {
    return this.fret === other.fret;
  }

  isOnString(guitarString: GuitarString): boolean {
    return this.string === guitarString;
  }

  raiseOctave(): Fret {
    this.fret += 12;
    return this;
  }

  toTab(): TabColumn {
    const blank = this.fret &lt; 10 ? &#x27;-&#x27; : &#x27;--&#x27;;

    switch (this.string) {
      case GuitarString.Sixth:
        return new TabColumn([blank, blank, blank, blank, blank, `${this.fret}`]);
      case GuitarString.Fifth:
        return new TabColumn([blank, blank, blank, blank, `${this.fret}`, blank]);
      case GuitarString.Fourth:
        return new TabColumn([blank, blank, blank, `${this.fret}`, blank, blank]);
      case GuitarString.Third:
        return new TabColumn([blank, blank, `${this.fret}`, blank, blank, blank]);
      case GuitarString.Second:
        return new TabColumn([blank, `${this.fret}`, blank, blank, blank, blank]);
      case GuitarString.First:
        return new TabColumn([`${this.fret}`, blank, blank, blank, blank, blank]);
      default:
        return TabColumn.Rest;
    }
  }
}

export class GuitarString {
  constructor(
    private name: string,
    private openStringPitch: Pitch,
    private index: number,
    private next: () =&gt; GuitarString
  ) {}

  public static readonly Sixth: GuitarString = new GuitarString(
    &#x27;Sixth&#x27;,
    Pitch.E,
    6,
    () =&gt; GuitarString.Fifth
  );
  public static readonly Fifth: GuitarString = new GuitarString(
    &#x27;Fifth&#x27;,
    Pitch.A,
    5,
    () =&gt; GuitarString.Fourth
  );
  public static readonly Fourth: GuitarString = new GuitarString(
    &#x27;Fourth&#x27;,
    Pitch.D,
    4,
    () =&gt; GuitarString.Third
  );
  public static readonly Third: GuitarString = new GuitarString(
    &#x27;Third&#x27;,
    Pitch.G,
    3,
    () =&gt; GuitarString.Second
  );
  public static readonly Second: GuitarString = new GuitarString(
    &#x27;Second&#x27;,
    Pitch.B,
    2,
    () =&gt; GuitarString.First
  );
  public static readonly First: GuitarString = new GuitarString(
    &#x27;First&#x27;,
    Pitch.E,
    1,
    () =&gt; GuitarString.First
  );

  public static readonly guitarStrings = [
    GuitarString.Sixth,
    GuitarString.Fifth,
    GuitarString.Fourth,
    GuitarString.Third,
    GuitarString.Second,
    GuitarString.First,
  ];

  fretFor(pitch: Pitch): Fret {
    return new Fret(this, this.openStringPitch.absoluteDistance(pitch));
  }

  isSame(other: GuitarString): boolean {
    return this.index === other.index;
  }

  get Next(): GuitarString {
    return this.next();
  }
}

export class Position {
  constructor(private name: string, private lowFret: Fret, private highFret: Fret) {}

  get Name() {
    return this.name;
  }

  public static readonly Open: Position = new Position(
    &#x27;Open&#x27;,
    new Fret(GuitarString.Sixth, 0),
    new Fret(GuitarString.First, 3)
  );

  public static readonly C: Position = new Position(
    &#x27;C&#x27;,
    new Fret(GuitarString.Sixth, 1),
    new Fret(GuitarString.First, 3)
  );

  public static readonly A: Position = new Position(
    &#x27;A&#x27;,
    new Fret(GuitarString.Sixth, 3),
    new Fret(GuitarString.First, 5)
  );

  public static readonly G: Position = new Position(
    &#x27;G&#x27;,
    new Fret(GuitarString.Sixth, 5),
    new Fret(GuitarString.First, 8)
  );

  public static readonly E: Position = new Position(
    &#x27;E&#x27;,
    new Fret(GuitarString.Sixth, 8),
    new Fret(GuitarString.First, 10)
  );

  public static readonly D: Position = new Position(
    &#x27;D&#x27;,
    new Fret(GuitarString.Sixth, 10),
    new Fret(GuitarString.First, 13)
  );

  isFretInPosition(fret: Fret, lowerMargin = 0, higherMargin = 0): boolean {
    const fretRangeFilter: (f: Fret) =&gt; boolean = (f) =&gt;
      (f.isHigher(this.lowFret, lowerMargin) || f.isSameFret(this.lowFret)) &amp;&amp;
      (f.isLower(this.highFret, higherMargin) || f.isSameFret(this.highFret));

    return fretRangeFilter(fret);
  }

  public static readonly guitarPositions = [
    Position.Open,
    Position.C,
    Position.A,
    Position.G,
    Position.E,
    Position.D,
  ];
}

export class GuitarChord {
  private chord: Fret[];

  constructor(chord: ClosedChord, private position: Position) {
    this.chord = this.create(chord);
  }

  toTab(): TabColumn[] {
    const tab: string[] = [];

    for (const guitarString of GuitarString.guitarStrings) {
      const fret = this.chord.find((f) =&gt; f.isOnString(guitarString));

      tab.push(this.fretToTab(fret));
    }
    return [new TabColumn(tab.reverse())];
  }

  private fretToTab(fret: Fret | undefined): string {
    const pad = this.pad();

    if (fret?.Number === undefined) {
      return pad + &#x27;-&#x27;;
    }

    if (fret?.Number &lt; 10) {
      return pad + fret.Number.toString();
    }

    return fret?.Number.toString();
  }

  private pad() {
    if (this.chord.some((f) =&gt; f.Number &gt; 9)) {
      return &#x27;-&#x27;;
    }

    return &#x27;&#x27;;
  }

  private create(chord: ClosedChord): Fret[] {
    const frets: Fret[] = [];

    let bassString = GuitarString.Sixth;
    for (const pitch of chord.Pitches) {
      const fret = this.mapPitchToFret(pitch, bassString);
      if (fret !== undefined) {
        frets.push(fret);
      }
      bassString = bassString.Next;
    }

    return frets;
  }

  private mapPitchToFret(pitch: Pitch, bassString: GuitarString): Fret | undefined {
    let guitarString = bassString;
    while (guitarString !== GuitarString.First) {
      const fret = guitarString.fretFor(pitch);

      if (this.position.isFretInPosition(fret, 1, 1)) {
        return fret;
      }

      guitarString = guitarString.Next;
    }

    return undefined;
  }
}

export class GuitarMelodicLine implements Iterable&lt;Fret&gt; {
  private line: Fret[];

  constructor(line: MelodicLine, private position: Position) {
    this.line = this.create(line);
  }

  toTab(): TabColumn[] {
    return this.line.map((fret) =&gt; fret.toTab());
  }

  private create(line: MelodicLine): Fret[] {
    const frets: Fret[] = [];

    for (const pitch of line) {
      if (line.Direction === MelodicLineDirection.Ascending) {
        const fret = this.mapPitchToFret(pitch, GuitarString.guitarStrings);
        if (fret !== undefined) {
          frets.push(fret);
        }
      }
      if (line.Direction === MelodicLineDirection.Descending) {
        const fret = this.mapPitchToFret(pitch, GuitarString.guitarStrings.reverse());
        if (fret !== undefined) {
          frets.push(fret);
        }
      }
    }

    return frets;
  }

  private mapPitchToFret(pitch: Pitch, guitarStrings: GuitarString[]): Fret | undefined {
    for (const guitarString of guitarStrings) {
      const fret = guitarString.fretFor(pitch);

      if (this.position.isFretInPosition(fret)) {
        return fret;
      }

      if (this.position.isFretInPosition(fret.raiseOctave())) {
        return fret;
      }
    }

    return undefined;
  }

  get(index: number): Fret {
    if (index &gt;= this.line.length) {
      throw new Error(&#x27;Invalid index&#x27;);
    }

    if (!this.line[index]) {
      throw new Error(&#x27;Invalid index&#x27;);
    }

    return this.line[index]!;
  }

  *[Symbol.iterator]() {
    for (const fret of this.line) {
      yield fret;
    }
  }
}

export class TabColumn {
  constructor(private values: string[]) {}

  public static readonly Start: TabColumn = new TabColumn(Array(6).fill(&#x27;|-&#x27;));
  public static readonly Bar: TabColumn = new TabColumn(Array(6).fill(&#x27;-|-&#x27;));
  public static readonly End: TabColumn = new TabColumn(Array(6).fill(&#x27;-|&#x27;));
  public static readonly Rest: TabColumn = new TabColumn(Array(6).fill(`-`));
  public static readonly StandardTunning: TabColumn = new TabColumn([&#x27;e&#x27;, &#x27;B&#x27;, &#x27;G&#x27;, &#x27;D&#x27;, &#x27;A&#x27;, &#x27;E&#x27;]);

  render(): string[] {
    return this.values;
  }
}

export class Tab {
  render(tab: TabColumn[]) {
    const standardTabStart = [TabColumn.StandardTunning, TabColumn.Start];
    const standardTabEnd = [TabColumn.End];
    const tabToRender = standardTabStart.concat(tab).concat(standardTabEnd);
    const tabElements = tabToRender.map((t) =&gt; t.render());

    return tabElements.reduce((a, b) =&gt; a.map((v, i) =&gt; v + b[i])).join(&#x27;\n&#x27;);
  }
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Tue, 26 Apr 2022 16:36:14 GMT</p>
    </body>
  </html>
  