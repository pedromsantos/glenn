
  <!DOCTYPE html>
  <html>
    <head>
      <title>Duration.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/Domain/Duration.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">250</td><td class="">250</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">export interface TimeSignature {
  get beatDuration(): number;
  get beatValue(): number;
  toBeats(duration: Duration): number;
  toFillMeasure(duration: Duration): number;
}

export class SimpleTimeSignature implements TimeSignature {
  constructor(private beats: number, private duration: Duration) {}

  get beatDuration(): number {
    return this.duration.value / this.beats;
  }

  get beatValue(): number {
    return this.duration.value;
  }

  toBeats(duration: Duration = this.duration): number {
    return duration.value / this.beatDuration / this.beats;
  }

  toFillMeasure(duration: Duration = this.duration): number {
    return (this.beatValue / duration.value) * this.beats;
  }
}

export class CompoundTimeSignature implements TimeSignature {
  constructor(private beats: number, private duration: Duration) {}

  get beatDuration(): number {
    return (this.duration.value * 3) / this.beats;
  }

  get beatValue(): number {
    return this.duration.value * 3;
  }

  toBeats(duration: Duration = this.duration): number {
    return duration.value * 0;
    //return (duration.value * 3) / this.beatDuration / this.beats;
  }

  toFillMeasure(duration: Duration = this.duration): number {
    return duration.value * 0;
    //return (this.beatValue / duration.value) * (this.beats / 3);
  }
}

export interface RhythmicDuration {
  toBeats(timeSignature: SimpleTimeSignature): number;
  toFillMeasure(timeSignature: SimpleTimeSignature, measure?: Measure): number;
  get value(): number;
}

// Stryker disable StringLiteral
export class Duration implements RhythmicDuration {
  constructor(private name: string, private duration: number) {}

  public static readonly Double: Duration = new Duration(&#x27;Double&#x27;, 2.0 / 1.0);
  public static readonly Whole: Duration = new Duration(&#x27;Whole&#x27;, 1.0);
  public static readonly Half: Duration = new Duration(&#x27;Half&#x27;, 1.0 / 2.0);
  public static readonly Quarter: Duration = new Duration(&#x27;Quarter&#x27;, 1.0 / 4.0);
  public static readonly Eighth: Duration = new Duration(&#x27;Eighth&#x27;, 1.0 / 8.0);
  public static readonly Sixteenth: Duration = new Duration(&#x27;Sixteenth&#x27;, 1.0 / 16.0);
  public static readonly ThirtySecond: Duration = new Duration(&#x27;ThirtySecond&#x27;, 1.0 / 32.0);
  public static readonly SixtyFourth: Duration = new Duration(&#x27;SixtyFourth&#x27;, 1.0 / 64.0);
  public static readonly HundredTwentyEighth: Duration = new Duration(
    &#x27;HundredTwentyEighth&#x27;,
    1.0 / 128.0
  );
  public static readonly TwoHundredFiftySixth: Duration = new Duration(
    &#x27;TwoHundredFiftySixth&#x27;,
    1.0 / 256.0
  );

  toBeats(timeSignature: SimpleTimeSignature): number {
    return timeSignature.toBeats(this);
  }

  toFillMeasure(timeSignature: SimpleTimeSignature, measure?: Measure): number {
    if (measure === undefined) return timeSignature.toFillMeasure(this);

    const needsBeats = this.toBeats(timeSignature);
    const usedBeats = measure.usedBeats();

    if (usedBeats &gt;= measure.maxBeats() || needsBeats &gt; usedBeats) return 0;

    return Math.max(
      0,
      this.toFillMeasure(timeSignature) - this.usedBeatsInInstanceDuration(timeSignature, usedBeats)
    );
  }

  get value() {
    return this.duration;
  }

  static From(value: number): Duration | undefined {
    return Duration.durations.find((d) =&gt; d.value === value);
  }

  private usedBeatsInInstanceDuration(
    timeSignature: SimpleTimeSignature,
    usedBeats: number
  ): number {
    return usedBeats / this.toBeats(timeSignature);
  }

  static durations = [
    Duration.Double,
    Duration.Whole,
    Duration.Half,
    Duration.Quarter,
    Duration.Eighth,
    Duration.Sixteenth,
    Duration.ThirtySecond,
    Duration.SixtyFourth,
    Duration.HundredTwentyEighth,
    Duration.TwoHundredFiftySixth,
  ];
}

// export class DottedDuration implements RhythmicDuration {
//   protected baseDuration: RhythmicDuration;

//   constructor(duration: Duration) {
//     this.baseDuration = duration;
//   }

//   toBeats(timeSignature: SimpleTimeSignature): number {
//     return 0;
//   }

//   toFillMeasure(timeSignature: SimpleTimeSignature, measure?: Measure): number {
//     return 0;
//   }

//   get value(): number {
//     return 0;
//   }
// }

export class RhythmicPhrase {
  private phrase: Duration[] = [];

  beats(timeSignature: SimpleTimeSignature): number {
    return this.phrase.reduce((acc, d) =&gt; acc + d.toBeats(timeSignature), 0);
  }

  push(duration: Duration): void {
    this.phrase.push(duration);
  }
}

export class Measure {
  private phrase: RhythmicPhrase;
  private timeSignature: SimpleTimeSignature;

  constructor(timeSignature: SimpleTimeSignature) {
    this.phrase = new RhythmicPhrase();
    this.timeSignature = timeSignature;
  }

  maxBeats(): number {
    return this.timeSignature.toFillMeasure();
  }

  add(duration: Duration) {
    this.phrase.push(duration);
  }

  usedBeats(): number {
    return this.phrase.beats(this.timeSignature);
  }
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Tue, 26 Apr 2022 16:36:14 GMT</p>
    </body>
  </html>
  