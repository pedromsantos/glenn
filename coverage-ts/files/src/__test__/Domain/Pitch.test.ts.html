
  <!DOCTYPE html>
  <html>
    <head>
      <title>Pitch.test.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/__test__/Domain/Pitch.test.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">1149</td><td class="">1149</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">/* eslint-disable jest/no-conditional-expect */
/* eslint-disable sonarjs/cognitive-complexity */

import Interval from &#x27;../../Domain/Interval&#x27;;
import Pitch from &#x27;../../Domain/Pitch&#x27;;
import * as fc from &#x27;fast-check&#x27;;

describe(&#x27;Pitch&#x27;, () =&gt; {
  describe(&#x27;sharp should raise it by half a tone&#x27;, () =&gt; {
    test(&#x27;sharp C is C#&#x27;, () =&gt; {
      expect(Pitch.C.sharp()).toBe(Pitch.CSharp);
    });

    test(&#x27;sharp C# is D&#x27;, () =&gt; {
      expect(Pitch.CSharp.sharp()).toBe(Pitch.D);
    });

    test(&#x27;sharp Db is D&#x27;, () =&gt; {
      expect(Pitch.DFlat.sharp()).toBe(Pitch.D);
    });

    test(&#x27;sharp D is D#&#x27;, () =&gt; {
      expect(Pitch.D.sharp()).toBe(Pitch.DSharp);
    });

    test(&#x27;sharp D# is E&#x27;, () =&gt; {
      expect(Pitch.DSharp.sharp()).toBe(Pitch.E);
    });

    test(&#x27;sharp EFlat is E&#x27;, () =&gt; {
      expect(Pitch.EFlat.sharp()).toBe(Pitch.E);
    });

    test(&#x27;sharp E is F&#x27;, () =&gt; {
      expect(Pitch.E.sharp()).toBe(Pitch.F);
    });

    test(&#x27;sharp F is F#&#x27;, () =&gt; {
      expect(Pitch.E.sharp()).toBe(Pitch.F);
    });

    test(&#x27;sharp F# is G&#x27;, () =&gt; {
      expect(Pitch.FSharp.sharp()).toBe(Pitch.G);
    });

    test(&#x27;sharp Gb is G&#x27;, () =&gt; {
      expect(Pitch.GFlat.sharp()).toBe(Pitch.G);
    });

    test(&#x27;sharp G is G#&#x27;, () =&gt; {
      expect(Pitch.G.sharp()).toBe(Pitch.GSharp);
    });

    test(&#x27;sharp G# is A&#x27;, () =&gt; {
      expect(Pitch.GSharp.sharp()).toBe(Pitch.A);
    });

    test(&#x27;sharp Ab is G&#x27;, () =&gt; {
      expect(Pitch.AFlat.sharp()).toBe(Pitch.A);
    });

    test(&#x27;sharp A is A#&#x27;, () =&gt; {
      expect(Pitch.A.sharp()).toBe(Pitch.ASharp);
    });

    test(&#x27;sharp A# is B&#x27;, () =&gt; {
      expect(Pitch.ASharp.sharp()).toBe(Pitch.B);
    });

    test(&#x27;sharp Bb is B&#x27;, () =&gt; {
      expect(Pitch.BFlat.sharp()).toBe(Pitch.B);
    });

    test(&#x27;sharp B is C&#x27;, () =&gt; {
      expect(Pitch.B.sharp()).toBe(Pitch.C);
    });
  });

  describe(&#x27;flat should lower it by half a tone&#x27;, () =&gt; {
    test(&#x27;sharp C is B&#x27;, () =&gt; {
      expect(Pitch.C.flat()).toBe(Pitch.B);
    });

    test(&#x27;flat C# is C&#x27;, () =&gt; {
      expect(Pitch.CSharp.flat()).toBe(Pitch.C);
    });

    test(&#x27;flat Db is C&#x27;, () =&gt; {
      expect(Pitch.DFlat.flat()).toBe(Pitch.C);
    });

    test(&#x27;flat D is Db&#x27;, () =&gt; {
      expect(Pitch.D.flat()).toBe(Pitch.DFlat);
    });

    test(&#x27;flat D# is D&#x27;, () =&gt; {
      expect(Pitch.DSharp.flat()).toBe(Pitch.D);
    });

    test(&#x27;flat EFlat is D&#x27;, () =&gt; {
      expect(Pitch.EFlat.flat()).toBe(Pitch.D);
    });

    test(&#x27;flat E is Eb&#x27;, () =&gt; {
      expect(Pitch.E.flat()).toBe(Pitch.EFlat);
    });

    test(&#x27;flat F is E&#x27;, () =&gt; {
      expect(Pitch.F.flat()).toBe(Pitch.E);
    });

    test(&#x27;flat F# is G&#x27;, () =&gt; {
      expect(Pitch.FSharp.flat()).toBe(Pitch.F);
    });

    test(&#x27;flat Gb is F&#x27;, () =&gt; {
      expect(Pitch.GFlat.flat()).toBe(Pitch.F);
    });

    test(&#x27;flat G is Gb&#x27;, () =&gt; {
      expect(Pitch.G.flat()).toBe(Pitch.GFlat);
    });

    test(&#x27;sharp G# is G&#x27;, () =&gt; {
      expect(Pitch.GSharp.flat()).toBe(Pitch.G);
    });

    test(&#x27;flat Ab is G&#x27;, () =&gt; {
      expect(Pitch.AFlat.flat()).toBe(Pitch.G);
    });

    test(&#x27;flat A is Ab&#x27;, () =&gt; {
      expect(Pitch.A.flat()).toBe(Pitch.AFlat);
    });

    test(&#x27;flat A# is A&#x27;, () =&gt; {
      expect(Pitch.ASharp.flat()).toBe(Pitch.A);
    });

    test(&#x27;flat Bb is A&#x27;, () =&gt; {
      expect(Pitch.BFlat.flat()).toBe(Pitch.A);
    });

    test(&#x27;flat B is Bb&#x27;, () =&gt; {
      expect(Pitch.B.flat()).toBe(Pitch.BFlat);
    });
  });

  describe(&#x27;measure semitones between&#x27;, () =&gt; {
    test(&#x27;C and C to zero semitones&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.C)).toBe(0);
    });
    test(&#x27;C and C# to one semitones&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.CSharp)).toBe(1);
    });
    test(&#x27;C and Db to one semitones&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.DFlat)).toBe(1);
    });
    test(&#x27;C and D to one semitones&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.D)).toBe(2);
    });

    test(&#x27;C and E flat to three semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.EFlat)).toBe(3);
    });

    test(&#x27;C and E to four semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.E)).toBe(4);
    });

    test(&#x27;C and F to five semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.F)).toBe(5);
    });

    test(&#x27;C and F sharp to six semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.FSharp)).toBe(6);
    });

    test(&#x27;C and G flat to six semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.GFlat)).toBe(6);
    });

    test(&#x27;C and G to seven semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.G)).toBe(7);
    });

    test(&#x27;C and G sharp to eight semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.GSharp)).toBe(8);
    });

    test(&#x27;C and A flat to eight semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.AFlat)).toBe(8);
    });

    test(&#x27;C and A to nine semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.A)).toBe(9);
    });

    test(&#x27;C and A sharp to ten semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.ASharp)).toBe(10);
    });

    test(&#x27;C and B flat to ten semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.BFlat)).toBe(10);
    });

    test(&#x27;C and B to eleven semitones`&#x27;, () =&gt; {
      expect(Pitch.C.absoluteDistance(Pitch.B)).toBe(11);
    });
  });

  describe(&#x27;measure intervals between&#x27;, () =&gt; {
    test(&#x27;C and Db to minor second&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.DFlat)).toBe(Interval.MinorSecond);
    });

    test(&#x27;C and D as MajorSecond&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.D)).toBe(Interval.MajorSecond);
    });

    test(&#x27;C and E flat as MinorThird&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.EFlat)).toBe(Interval.MinorThird);
    });

    test(&#x27;C and E as MajorThird&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.E)).toBe(Interval.MajorThird);
    });

    test(&#x27;C and F as PerfectFourth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.F)).toBe(Interval.PerfectFourth);
    });

    test(&#x27;C and F sharp as AugmentedFourth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.FSharp)).toBe(Interval.AugmentedFourth);
    });

    test(&#x27;C and G flat as DiminishedFifth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.GFlat)).toBe(Interval.DiminishedFifth);
    });

    test(&#x27;C and G as PerfectFifth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.G)).toBe(Interval.PerfectFifth);
    });

    test(&#x27;C and G sharp as AugmentedFifth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.GSharp)).toBe(Interval.AugmentedFifth);
    });

    test(&#x27;C and A flat as MinorSixth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.AFlat)).toBe(Interval.MinorSixth);
    });

    test(&#x27;C and A as MajorSixth&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.A)).toBe(Interval.MajorSixth);
    });

    test(&#x27;C and B flat as MinorSeventh&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.BFlat)).toBe(Interval.MinorSeventh);
    });

    test(&#x27;C and B as MajorSeventh&#x27;, () =&gt; {
      expect(Pitch.C.intervalTo(Pitch.B)).toBe(Interval.MajorSeventh);
    });

    test(&#x27;D and F as MinorThird&#x27;, () =&gt; {
      expect(Pitch.D.intervalTo(Pitch.F)).toBe(Interval.MinorThird);
    });
  });

  describe(&#x27;transpose using a&#x27;, () =&gt; {
    test(&#x27;Unison from C to C&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.Unison)).toBe(Pitch.C);
    });

    test(&#x27;Unison from C# to C#&#x27;, () =&gt; {
      expect(Pitch.CSharp.transpose(Interval.Unison)).toBe(Pitch.CSharp);
    });

    test(&#x27;MinorSecond from C to D flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MinorSecond)).toBe(Pitch.DFlat);
    });

    test(&#x27;MajorSecond from C to D&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MajorSecond)).toBe(Pitch.D);
    });

    test(&#x27;AugmentedSecond from C to D sharp&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.AugmentedSecond)).toBe(Pitch.DSharp);
    });

    test(&#x27;MinorThird from C to E flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MinorThird)).toBe(Pitch.EFlat);
    });

    test(&#x27;MajorThird from C to E&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MajorThird)).toBe(Pitch.E);
    });

    test(&#x27;PerfectFourth from C to F&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.PerfectFourth)).toBe(Pitch.F);
    });

    test(&#x27;AugmentedFourth from C to F sharp&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.AugmentedFourth)).toBe(Pitch.FSharp);
    });

    test(&#x27;DiminishedFifth from C to G flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.DiminishedFifth)).toBe(Pitch.GFlat);
    });

    test(&#x27;PerfectFifth from C to G&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.PerfectFifth)).toBe(Pitch.G);
    });

    test(&#x27;PerfectFifth from D to A&#x27;, () =&gt; {
      expect(Pitch.D.transpose(Interval.PerfectFifth)).toBe(Pitch.A);
    });

    test(&#x27;AugmentedFifth from C to G sharp&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.AugmentedFifth)).toBe(Pitch.GSharp);
    });

    test(&#x27;MinorSixth from C to A flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MinorSixth)).toBe(Pitch.AFlat);
    });

    test(&#x27;MajorSixth from C to A&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MajorSixth)).toBe(Pitch.A);
    });

    test(&#x27;diminished seventh from C to B flat flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.DiminishedSeventh)).toBe(Pitch.A);
    });

    test(&#x27;diminished seventh from G to E&#x27;, () =&gt; {
      expect(Pitch.G.transpose(Interval.DiminishedSeventh)).toBe(Pitch.E);
    });

    test(&#x27;minor seventh from C to B flat&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MinorSeventh)).toBe(Pitch.BFlat);
    });

    test(&#x27;MajorSeventh from C to B&#x27;, () =&gt; {
      expect(Pitch.C.transpose(Interval.MajorSeventh)).toBe(Pitch.B);
    });

    test(&#x27;augmented ninth from G to A#&#x27;, () =&gt; {
      expect(Pitch.G.transpose(Interval.AugmentedNinth)).toBe(Pitch.ASharp);
    });

    test(&#x27;perfect eleventh from G to C&#x27;, () =&gt; {
      expect(Pitch.G.transpose(Interval.PerfectEleventh)).toBe(Pitch.C);
    });

    test(&#x27;augmented second from D to E#&#x27;, () =&gt; {
      expect(Pitch.D.transpose(Interval.AugmentedSecond)).toBe(Pitch.ESharp);
    });

    test(&#x27;minor third from G to Bb&#x27;, () =&gt; {
      expect(Pitch.G.transpose(Interval.MinorThird)).toBe(Pitch.BFlat);
    });

    test(&#x27;major third from G to B&#x27;, () =&gt; {
      expect(Pitch.G.transpose(Interval.MajorThird)).toBe(Pitch.B);
    });
  });

  describe(&#x27;properties&#x27;, () =&gt; {
    test(&#x27;sharping and flating a pitch results in the original note pitch&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          const newPitch = pitch.sharp().flat();

          expect(newPitch.NumericValue).toBe(pitch.NumericValue);
        }),
        { verbose: true }
      );
    });

    test(&#x27;The natural pitch of a pitch starts with the same ptch name&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          const newPitch = pitch.natural();

          expect(newPitch.Name[0]).toBe(pitch.Name[0]);
        }),
        { verbose: true }
      );
    });

    test(&#x27;flating and sharping a pitch results in the original note pitch&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          const newPitch = pitch.flat().sharp();

          expect(newPitch.NumericValue).toBe(pitch.NumericValue);
        }),
        { verbose: true }
      );
    });

    test(&#x27;a sharped note has a higher pitch except B&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          if (pitch === Pitch.B) {
            expect(pitch.sharp().NumericValue).toBeLessThan(pitch.NumericValue);
          } else {
            expect(pitch.sharp().NumericValue).toBeGreaterThan(pitch.NumericValue);
          }
        }),
        { verbose: true }
      );
    });

    test(&#x27;a flatted note has a lower pitch except C&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          if (pitch === Pitch.C) {
            expect(pitch.flat().NumericValue).toBeGreaterThan(pitch.NumericValue);
          } else {
            expect(pitch.flat().NumericValue).toBeLessThan(pitch.NumericValue);
          }
        }),
        { verbose: true }
      );
    });

    test(&#x27;pitch can be converted to and from PitchState&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), (pitch) =&gt; {
          const from = Pitch.From(pitch.To);

          expect(pitch.NumericValue).toBe(from?.NumericValue);
        }),
        { verbose: true }
      );
    });

    test(&#x27;measure semitones between a note and itself sharp n times to n semitones&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), fc.nat({ max: 12 }), (pitch, distance) =&gt; {
          let transposed = pitch;

          for (let i = 0; i &lt; distance; i++) {
            transposed = transposed.sharp();
          }

          if (distance === 12) {
            expect(pitch.absoluteDistance(transposed)).toBe(0);
          } else {
            expect(pitch.absoluteDistance(transposed)).toBe(distance);
          }
        }),
        { verbose: true }
      );
    });

    test(&#x27;measure semitones between a note and itself flat n times to n semitones&#x27;, () =&gt; {
      fc.assert(
        fc.property(fc.constantFrom(...Pitch.pitches), fc.nat({ max: 12 }), (pitch, distance) =&gt; {
          let transposed = pitch;

          for (let i = 0; i &lt; distance; i++) {
            transposed = transposed.flat();
          }

          if (distance === 12 || distance === 0) {
            expect(pitch.absoluteDistance(transposed)).toBe(0);
          } else {
            expect(pitch.absoluteDistance(transposed)).toBe(12 - distance);
          }
        }),
        { verbose: true }
      );
    });

    test(&#x27;measure interval between a pitch and itself transposed by an interval to be the interval&#x27;, () =&gt; {
      fc.assert(
        fc.property(
          fc.constantFrom(...Pitch.pitches),
          fc.constantFrom(...Interval.intervals),
          (pitch, interval) =&gt; {
            const to = pitch.transpose(interval);
            const resultingInterval = pitch.intervalTo(to);

            switch (interval) {
              case Interval.MajorNinth:
                expect(resultingInterval).toBe(Interval.MajorSecond);
                break;
              case Interval.PerfectEleventh:
                expect(resultingInterval).toBe(Interval.PerfectFourth);
                break;
              case Interval.AugmentedEleventh:
                expect(resultingInterval).toBe(Interval.AugmentedFourth);
                break;
              case Interval.MajorThirteenth:
                expect(resultingInterval).toBe(Interval.MajorSixth);
                break;
              case Interval.PerfectOctave:
                expect(resultingInterval).toBe(Interval.Unison);
                break;
              case Interval.DiminishedSeventh:
                if (
                  resultingInterval === Interval.MajorSixth ||
                  resultingInterval === Interval.DiminishedSeventh
                )
                  expect(resultingInterval).toBe(resultingInterval);
                break;
              case Interval.MinorThird:
              case Interval.AugmentedNinth:
              case Interval.AugmentedSecond:
                if (
                  resultingInterval === Interval.MinorThird ||
                  resultingInterval === Interval.AugmentedSecond
                )
                  expect(resultingInterval).toBe(resultingInterval);
                break;
              case Interval.MinorThirteenth:
              case Interval.MinorSixth:
              case Interval.AugmentedFifth:
                if (
                  resultingInterval === Interval.MinorThirteenth ||
                  resultingInterval === Interval.MinorSixth ||
                  resultingInterval === Interval.AugmentedFifth
                )
                  expect(resultingInterval).toBe(resultingInterval);
                break;
              case Interval.Tritone:
              case Interval.DiminishedFifth:
              case Interval.AugmentedFourth:
                if (
                  resultingInterval === Interval.AugmentedFourth ||
                  resultingInterval === Interval.DiminishedFifth
                )
                  expect(resultingInterval).toBe(resultingInterval);
                break;
              case Interval.MinorNinth:
              case Interval.MinorSecond:
              case Interval.AugmentedUnison:
                if (
                  resultingInterval === Interval.MinorNinth ||
                  resultingInterval === Interval.MinorSecond ||
                  resultingInterval === Interval.AugmentedUnison
                )
                  expect(resultingInterval).toBe(resultingInterval);
                break;
              default:
                expect(resultingInterval).toBe(interval);
            }
          }
        ),
        { verbose: true }
      );
    });
  });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Tue, 26 Apr 2022 16:36:14 GMT</p>
    </body>
  </html>
  